{% extends "base.html" %}

{% block title %}任务管理 - FanqieQimaoDownloader{% endblock %}

{% block content %}
<div class="px-4 py-6 sm:px-0">
    <div class="bg-white shadow overflow-hidden sm:rounded-md">
        <div class="px-4 py-5 sm:p-6">
            <h3 class="text-lg leading-6 font-medium text-gray-900 mb-4">下载任务</h3>

            <!-- 任务列表 -->
            <div x-data="tasksList()" x-init="init()">
                <div x-show="tasks.length > 0" class="space-y-4">
                    <template x-for="task in tasks" :key="task.id">
                        <div class="border rounded-lg p-4">
                            <div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-3 mb-3">
                                <div class="flex-1 min-w-0">
                                    <div class="flex flex-wrap items-center gap-2">
                                        <h4 class="text-base sm:text-lg font-medium text-gray-900">
                                            书籍ID: <span x-text="task.book_id"></span>
                                        </h4>
                                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium"
                                              :class="task.task_type === 'full_download' ? 'bg-blue-100 text-blue-800' : 'bg-green-100 text-green-800'">
                                            <span x-text="task.task_type === 'full_download' ? '完整下载' : '增量更新'"></span>
                                        </span>
                                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium"
                                              :class="getStatusClass(task.status)">
                                            <span x-text="getStatusText(task.status)"></span>
                                        </span>
                                    </div>
                                    <p class="text-xs sm:text-sm text-gray-600 mt-1">
                                        创建时间: <span x-text="new Date(task.created_at).toLocaleString()"></span>
                                    </p>
                                </div>
                                <button @click="cancelTask(task.id)"
                                        x-show="task.status === 'pending' || task.status === 'running'"
                                        class="inline-flex items-center justify-center px-3 py-1.5 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700 w-full sm:w-auto">
                                    <i class="fas fa-times mr-1"></i>
                                    取消
                                </button>
                            </div>

                            <!-- 进度条 -->
                            <div x-show="task.status === 'running'" class="mb-3">
                                <div class="flex justify-between text-sm text-gray-600 mb-1">
                                    <span>进度</span>
                                    <span x-text="task.progress.toFixed(1) + '%'"></span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-2">
                                    <div class="bg-blue-600 h-2 rounded-full transition-all duration-300"
                                         :style="`width: ${task.progress}%`"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span x-text="`${task.downloaded_chapters}/${task.total_chapters} 章节`"></span>
                                    <span x-show="task.failed_chapters > 0" class="text-red-600">
                                        失败: <span x-text="task.failed_chapters"></span>
                                    </span>
                                </div>
                            </div>

                            <!-- 错误信息 -->
                            <div x-show="task.error_message" class="bg-red-50 border border-red-200 rounded p-3">
                                <p class="text-sm text-red-800" x-text="task.error_message"></p>
                            </div>
                        </div>
                    </template>
                </div>

                <!-- 空状态 -->
                <div x-show="tasks.length === 0 && !loading" class="text-center py-12">
                    <i class="fas fa-tasks text-gray-400 text-4xl"></i>
                    <h3 class="mt-2 text-sm font-medium text-gray-900">暂无任务</h3>
                    <p class="mt-1 text-sm text-gray-500">添加书籍后开始下载任务</p>
                </div>

                <!-- 加载状态 -->
                <div x-show="loading" class="text-center py-8">
                    <i class="fas fa-spinner fa-spin text-blue-600 text-2xl"></i>
                    <p class="mt-2 text-sm text-gray-600">加载中...</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
function tasksList() {
    return {
        tasks: [],
        loading: false,
        refreshInterval: null,
        websockets: {},  // task_id -> WebSocket
        reconnectAttempts: {},  // task_id -> 重连次数
        maxReconnectAttempts: 5,
        fallbackPolling: false,  // 是否降级为轮询

        async loadTasks() {
            this.loading = true;
            try {
                const response = await fetch('/api/tasks/');
                const data = await response.json();
                this.tasks = data.tasks || [];
                
                // 为运行中的任务建立 WebSocket 连接
                this.tasks.forEach(task => {
                    if ((task.status === 'pending' || task.status === 'running') && !this.websockets[task.id]) {
                        this.connectWebSocket(task.id);
                    }
                });
            } catch (error) {
                console.error('Failed to load tasks:', error);
            } finally {
                this.loading = false;
            }
        },

        init() {
            this.loadTasks();
            // 降级轮询：每30秒检查一次任务列表（主要用于发现新任务）
            this.refreshInterval = setInterval(() => {
                this.loadTasks();
            }, 30000);
        },

        destroy() {
            if (this.refreshInterval) {
                clearInterval(this.refreshInterval);
            }
            // 关闭所有 WebSocket 连接
            Object.values(this.websockets).forEach(ws => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.close();
                }
            });
            this.websockets = {};
        },

        getWebSocketUrl(taskId) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${protocol}//${window.location.host}/ws/tasks/${taskId}`;
        },

        connectWebSocket(taskId) {
            if (this.websockets[taskId]) {
                return;  // 已有连接
            }

            const url = this.getWebSocketUrl(taskId);
            console.log(`Connecting WebSocket for task ${taskId}...`);
            
            const ws = new WebSocket(url);
            this.websockets[taskId] = ws;

            ws.onopen = () => {
                console.log(`WebSocket connected for task ${taskId}`);
                this.reconnectAttempts[taskId] = 0;  // 重置重连计数
                
                // 开始心跳
                this.startHeartbeat(taskId);
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    this.handleWebSocketMessage(taskId, message);
                } catch (error) {
                    console.error('Failed to parse WebSocket message:', error);
                }
            };

            ws.onclose = (event) => {
                console.log(`WebSocket closed for task ${taskId}:`, event.code, event.reason);
                delete this.websockets[taskId];
                
                // 检查任务是否还在运行
                const task = this.tasks.find(t => t.id === taskId);
                if (task && (task.status === 'pending' || task.status === 'running')) {
                    this.attemptReconnect(taskId);
                }
            };

            ws.onerror = (error) => {
                console.error(`WebSocket error for task ${taskId}:`, error);
            };
        },

        handleWebSocketMessage(taskId, message) {
            const task = this.tasks.find(t => t.id === taskId);
            if (!task) return;

            switch (message.type) {
                case 'progress':
                    // 更新任务进度
                    task.status = message.data.status;
                    task.total_chapters = message.data.total_chapters;
                    task.downloaded_chapters = message.data.downloaded_chapters;
                    task.failed_chapters = message.data.failed_chapters;
                    task.progress = message.data.progress;
                    task.error_message = message.data.error_message;
                    break;

                case 'completed':
                    // 任务完成
                    task.status = message.data.success ? 'completed' : 'failed';
                    task.progress = 100;
                    // 关闭 WebSocket
                    const ws = this.websockets[taskId];
                    if (ws) {
                        ws.close();
                        delete this.websockets[taskId];
                    }
                    // 刷新列表获取最新状态
                    setTimeout(() => this.loadTasks(), 1000);
                    break;

                case 'error':
                    console.error(`Task ${taskId} error:`, message.data.error_message);
                    task.error_message = message.data.error_message;
                    break;

                case 'pong':
                    // 心跳响应
                    break;
            }
        },

        attemptReconnect(taskId) {
            const attempts = this.reconnectAttempts[taskId] || 0;
            
            if (attempts >= this.maxReconnectAttempts) {
                console.log(`Max reconnect attempts reached for task ${taskId}, falling back to polling`);
                this.fallbackPolling = true;
                // 切换到更频繁的轮询
                if (this.refreshInterval) {
                    clearInterval(this.refreshInterval);
                }
                this.refreshInterval = setInterval(() => {
                    this.loadTasks();
                }, 3000);
                return;
            }

            // 指数退避重连
            const delay = Math.min(1000 * Math.pow(2, attempts), 30000);
            console.log(`Reconnecting WebSocket for task ${taskId} in ${delay}ms (attempt ${attempts + 1})`);
            
            this.reconnectAttempts[taskId] = attempts + 1;
            
            setTimeout(() => {
                const task = this.tasks.find(t => t.id === taskId);
                if (task && (task.status === 'pending' || task.status === 'running')) {
                    this.connectWebSocket(taskId);
                }
            }, delay);
        },

        startHeartbeat(taskId) {
            const ws = this.websockets[taskId];
            if (!ws) return;

            const heartbeat = setInterval(() => {
                if (ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'ping' }));
                } else {
                    clearInterval(heartbeat);
                }
            }, 30000);  // 每30秒发送一次心跳
        },

        getStatusClass(status) {
            const classes = {
                'pending': 'bg-gray-100 text-gray-800',
                'running': 'bg-blue-100 text-blue-800',
                'completed': 'bg-green-100 text-green-800',
                'failed': 'bg-red-100 text-red-800',
                'cancelled': 'bg-yellow-100 text-yellow-800'
            };
            return classes[status] || classes.pending;
        },

        getStatusText(status) {
            const texts = {
                'pending': '等待中',
                'running': '运行中',
                'completed': '已完成',
                'failed': '失败',
                'cancelled': '已取消'
            };
            return texts[status] || '未知';
        },

        async cancelTask(taskId) {
            if (!confirm('确定要取消这个任务吗？')) return;

            try {
                const response = await fetch(`/api/tasks/${taskId}/cancel`, {
                    method: 'POST'
                });

                if (response.ok) {
                    alert('任务已取消！');
                    // 关闭 WebSocket
                    const ws = this.websockets[taskId];
                    if (ws) {
                        ws.close();
                        delete this.websockets[taskId];
                    }
                    this.loadTasks(); // 刷新列表
                } else {
                    throw new Error('取消失败');
                }
            } catch (error) {
                console.error('Cancel task failed:', error);
                alert('取消任务失败，请稍后重试');
            }
        }
    }
}
</script>
{% endblock %}